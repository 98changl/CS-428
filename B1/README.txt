Assignment B1 Report
Unity Navigation Basics

a. Describe your braking mechanism for agents.
  - Agents in the program have auto braking on where once an agent encounters an obstacle, it stops and recalculates a new path for the agent to get to the destination. The braking mechanism is simple as the agent will stop and recalculate a new path once a game object enters the agent's nav mesh agent obstacle avoidance radius. This mechanism will only be applied to objects on the NavMesh.

b. Describe a way for implementing how an agent can avoid obstacles without carving.
  - A method of avoiding obstacles without carving is to take into account agent speed. Without carving, if an agent encounters an obstacle on the NavMesh that's blocking the path, the agent will slow down significantly or stop due to the obstruction. By implementing a tracker for agent speed in Update(), once an agent's speed is less than the max speed of an agent or has hit zero, the AgentScript can assume that an obstacle has disrupted the agent. Once that condition has been fulfilled, if the current position of the agent is not the desired destination, then the AgentScript will tell the program to recalculate a new path for the agent.

c. Explain the difference in behavior between carving and non-carving options for a NavMeshObstacle. When and why should you use carving? What is the issue with making all obstacles carving? What is the issue with making all obstacles non-carving?
  - Carving allows the obstacle to carve space around it into the nav mesh when it is stationary. Therefore, when a lot of obstacles are close to each other possibly causing obstructions of the path, carving will allow the path finder to better navigate the navigation mesh by carving out any navigation mesh that is too close. You should use carving on objects that can be moved or will obstruct the pathway of the player. Making all of the obstacles carving may end up carving out too much of the navigation mesh and not allow the player to move around or it may cause the pathfinder to not be able to find an optimal path around the obstacles. Making all of the obstacles non-carving may cause the pathfinder to get stuck on obstacles if there are too many blocking an optimal path.

Extra credit opportunities:

a. Create an adversarial agent which all normal agents avoid. The more apparent their avoidance, the more points will be given. You should be able to select and move adversarial agents just like your normal agents (using the mouseâ€™s left and right clicks). You are not permitted to use a large-radius collider to push normal agents away.
  - The adversarial agents have almost the exact same functionalities as a standard agent. The major difference between an adversarial agent and standard agent is their obstacle avoidance radius.

b. Extract the navigation mesh into a graph and implement your own navigation from scratch using A*. You must be able to navigate to positions that are not points on the triangulation, and your paths must be as straight as possible.
  - For the A* Algorithm, the program management is split between a GameManager and the agent itself. The GameManager contains the script for graph creation and the script that calculates the path the agent should take. At start, the Graph script takes in information about map obstacles and the NavMesh, then generates a graph of nodes that covers the map. These nodes contain the position vectors they represent and whether the node is an obstacle that can be passed through. Once the graph has been created, the GameManager uses the Navigation script to calculate the best path when requested by an agent. The custom agent requests a path from the GameManager which uses the Navigation script to generate a path based the A* algorithm. When the Navigation script is called, the algorithm starts with the starting position of the agent and checks each neighbor node for the most optimal adjacent node to travel to based on distance calculations made by the script. These distance calculations are the node's distance from the next adjecent node it can travel to and the distance between the node and the destination. Once Navigation finishes creating a path, the agent will recieve a list of nodes that comprises of the position vectors the agent should travel to. The custom agent takes this list of nodes and travels to the position stored in each node in the list. 
